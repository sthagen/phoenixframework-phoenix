{"version":3,"sources":["webpack://phoenix/webpack/universalModuleDefinition","webpack://phoenix/./js/phoenix/utils.js","webpack://phoenix/./js/phoenix/constants.js","webpack://phoenix/./js/phoenix/push.js","webpack://phoenix/./js/phoenix/timer.js","webpack://phoenix/./js/phoenix/channel.js","webpack://phoenix/./js/phoenix/ajax.js","webpack://phoenix/./js/phoenix/longpoll.js","webpack://phoenix/./js/phoenix/presence.js","webpack://phoenix/./js/phoenix/serializer.js","webpack://phoenix/./js/phoenix/socket.js","webpack://phoenix/./js/phoenix/index-exposed.js","webpack://phoenix/./node_modules/expose-loader/dist/runtime/getGlobalThis.js","webpack://phoenix/webpack/bootstrap","webpack://phoenix/webpack/runtime/define property getters","webpack://phoenix/webpack/runtime/global","webpack://phoenix/webpack/runtime/hasOwnProperty shorthand","webpack://phoenix/webpack/runtime/make namespace object","webpack://phoenix/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","closure","value","globalSelf","self","phxWindow","window","global","CHANNEL_STATES","CHANNEL_EVENTS","CHANNEL_LIFECYCLE_EVENTS","Push","channel","event","payload","timeout","receivedResp","timeoutTimer","recHooks","sent","reset","send","hasReceived","startTimeout","socket","push","topic","ref","join_ref","joinRef","status","callback","response","cancelRefEvent","refEvent","_ref","filter","h","forEach","off","clearTimeout","cancelTimeout","makeRef","replyEventName","on","matchReceive","setTimeout","trigger","Timer","timerCalc","timer","tries","Channel","params","state","bindings","bindingRef","joinedOnce","joinPush","pushBuffer","stateChangeRefs","rejoinTimer","isConnected","rejoin","rejoinAfterMs","onError","onOpen","isErrored","receive","pushEvent","scheduleTimeout","onClose","hasLogger","log","remove","reason","isJoining","Error","bind","isJoined","canPush","leavePush","_event","indexOf","isLifecycleEvent","isLeaving","leaveOpenTopic","resend","handledPayload","onMessage","eventBindings","i","length","Ajax","states","complete","method","endPoint","accept","body","ontimeout","XDomainRequest","req","xdomainRequest","XMLHttpRequest","xhrRequest","open","onload","parseJSON","responseText","onprogress","setRequestHeader","onerror","onreadystatechange","readyState","resp","JSON","parse","e","console","obj","parentKey","queryStr","key","Object","prototype","hasOwnProperty","call","paramKey","paramVal","serialize","encodeURIComponent","join","url","keys","prefix","match","LongPoll","token","skipHeartbeat","onopen","onmessage","onclose","pollEndpoint","normalizeEndpoint","poll","replace","RegExp","appendParams","close","closeAndRetry","request","endpointURL","messages","msg","data","_code","_reason","Presence","opts","events","diff","pendingDiffs","caller","onJoin","onLeave","onSync","newState","syncState","syncDiff","inPendingSyncState","by","list","currentState","clone","joins","leaves","map","presence","newPresence","currentPresence","newRefs","metas","m","phx_ref","curRefs","joinedMetas","leftMetas","joinedRefs","curMetas","unshift","leftPresence","refsToRemove","p","presences","chooser","pres","func","getOwnPropertyNames","stringify","HEADER_LENGTH","META_LENGTH","KINDS","reply","broadcast","constructor","ArrayBuffer","binaryEncode","rawPayload","binaryDecode","message","metaLength","header","view","DataView","offset","setUint8","Array","from","char","charCodeAt","combined","Uint8Array","byteLength","set","buffer","kind","getUint8","decoder","TextDecoder","decodePush","decodeReply","decodeBroadcast","joinRefSize","topicSize","eventSize","decode","slice","refSize","Socket","stateChangeCallbacks","error","channels","sendBuffer","transport","WebSocket","defaultEncoder","defaultDecoder","closeWasClean","binaryType","connectClock","encode","awaitingConnectionOnPageShow","addEventListener","_e","conn","disconnect","connect","heartbeatIntervalMs","reconnectAfterMs","logger","longpollerTimeout","vsn","heartbeatTimer","pendingHeartbeatRef","reconnectTimer","teardown","location","protocol","uri","charAt","host","code","endPointURL","onConnOpen","onConnError","onConnMessage","onConnClose","flushSendBuffer","resetHeartbeat","abnormalClose","sendHeartbeat","waitForBufferDone","waitForSocketClosed","bufferedAmount","triggerChanError","isClosed","connectionState","c","refs","chanParams","chan","result","newRef","toString","heartbeatTimeout","rawMessage","isMember","dupChannel","find","leave","___EXPOSE_LOADER_IMPORT___","___EXPOSE_LOADER_GLOBAL_THIS___","globalThis","g","Function","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","prop","r","Symbol","toStringTag"],"mappings":"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","file":"phoenix.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phoenix\"] = factory();\n\telse\n\t\troot[\"phoenix\"] = factory();\n})(this, function() {\nreturn ","// wraps value in closure or returns closure\nexport let closure = (value) => {\n  if(typeof value === \"function\"){\n    return value\n  } else {\n    let closure = function (){ return value }\n    return closure\n  }\n}\n","export const globalSelf = typeof self !== \"undefined\" ? self : null\nexport const phxWindow = typeof window !== \"undefined\" ? window : null\nexport const global = globalSelf || phxWindow || this\nexport const DEFAULT_VSN = \"2.0.0\"\nexport const SOCKET_STATES = {connecting: 0, open: 1, closing: 2, closed: 3}\nexport const DEFAULT_TIMEOUT = 10000\nexport const WS_CLOSE_NORMAL = 1000\nexport const CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\",\n}\nexport const CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n}\nexport const CHANNEL_LIFECYCLE_EVENTS = [\n  CHANNEL_EVENTS.close,\n  CHANNEL_EVENTS.error,\n  CHANNEL_EVENTS.join,\n  CHANNEL_EVENTS.reply,\n  CHANNEL_EVENTS.leave\n]\nexport const TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n}\n","/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\nexport default class Push {\n  constructor(channel, event, payload, timeout){\n    this.channel = channel\n    this.event = event\n    this.payload = payload || function (){ return {} }\n    this.receivedResp = null\n    this.timeout = timeout\n    this.timeoutTimer = null\n    this.recHooks = []\n    this.sent = false\n  }\n\n  /**\n   *\n   * @param {number} timeout\n   */\n  resend(timeout){\n    this.timeout = timeout\n    this.reset()\n    this.send()\n  }\n\n  /**\n   *\n   */\n  send(){\n    if(this.hasReceived(\"timeout\")){ return }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    })\n  }\n\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n  receive(status, callback){\n    if(this.hasReceived(status)){\n      callback(this.receivedResp.response)\n    }\n\n    this.recHooks.push({status, callback})\n    return this\n  }\n\n  /**\n   * @private\n   */\n  reset(){\n    this.cancelRefEvent()\n    this.ref = null\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n  }\n\n  /**\n   * @private\n   */\n  matchReceive({status, response, _ref}){\n    this.recHooks.filter(h => h.status === status)\n      .forEach(h => h.callback(response))\n  }\n\n  /**\n   * @private\n   */\n  cancelRefEvent(){\n    if(!this.refEvent){ return }\n    this.channel.off(this.refEvent)\n  }\n\n  /**\n   * @private\n   */\n  cancelTimeout(){\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n\n  /**\n   * @private\n   */\n  startTimeout(){\n    if(this.timeoutTimer){ this.cancelTimeout() }\n    this.ref = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent()\n      this.cancelTimeout()\n      this.receivedResp = payload\n      this.matchReceive(payload)\n    })\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {})\n    }, this.timeout)\n  }\n\n  /**\n   * @private\n   */\n  hasReceived(status){\n    return this.receivedResp && this.receivedResp.status === status\n  }\n\n  /**\n   * @private\n   */\n  trigger(status, response){\n    this.channel.trigger(this.refEvent, {status, response})\n  }\n}\n","/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\nexport default class Timer {\n  constructor(callback, timerCalc){\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset(){\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout(){\n    clearTimeout(this.timer)\n\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n","import {closure} from \"./utils\"\nimport {\n  CHANNEL_EVENTS,\n  CHANNEL_LIFECYCLE_EVENTS,\n  CHANNEL_STATES,\n} from \"./constants\"\n\nimport Push from \"./push\"\nimport Timer from \"./timer\"\n\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\nexport default class Channel {\n  constructor(topic, params, socket){\n    this.state = CHANNEL_STATES.closed\n    this.topic = topic\n    this.params = closure(params || {})\n    this.socket = socket\n    this.bindings = []\n    this.bindingRef = 0\n    this.timeout = this.socket.timeout\n    this.joinedOnce = false\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\n    this.pushBuffer = []\n    this.stateChangeRefs = []\n\n    this.rejoinTimer = new Timer(() => {\n      if(this.socket.isConnected()){ this.rejoin() }\n    }, this.socket.rejoinAfterMs)\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()))\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset()\n      if(this.isErrored()){ this.rejoin() }\n    })\n    )\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach(pushEvent => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError(reason => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason)\n      if(this.isJoining()){ this.joinPush.reset() }\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.joinPush.receive(\"timeout\", () => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout)\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout)\n      leavePush.send()\n      this.state = CHANNEL_STATES.errored\n      this.joinPush.reset()\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  join(timeout = this.timeout){\n    if(this.joinedOnce){\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\")\n    } else {\n      this.timeout = timeout\n      this.joinedOnce = true\n      this.rejoin()\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n  onClose(callback){\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n  onError(callback){\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason))\n  }\n\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n  on(event, callback){\n    let ref = this.bindingRef++\n    this.bindings.push({event, ref, callback})\n    return ref\n  }\n\n  /**\n   * Unsubscribes off of channel events\n   *\n   * Use the ref returned from a channel.on() to unsubscribe one\n   * handler, or pass nothing for the ref to unsubscribe all\n   * handlers for the given event.\n   *\n   * @example\n   * // Unsubscribe the do_stuff handler\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * channel.off(\"event\", ref1)\n   *\n   * // Unsubscribe all handlers from event\n   * channel.off(\"event\")\n   *\n   * @param {string} event\n   * @param {integer} ref\n   */\n  off(event, ref){\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref))\n    })\n  }\n\n  /**\n   * @private\n   */\n  canPush(){ return this.socket.isConnected() && this.isJoined() }\n\n  /**\n   * Sends a message `event` to phoenix with the payload `payload`.\n   * Phoenix receives this in the `handle_in(event, payload, socket)`\n   * function. if phoenix replies or it times out (default 10000ms),\n   * then optionally the reply can be received.\n   *\n   * @example\n   * channel.push(\"event\")\n   *   .receive(\"ok\", payload => console.log(\"phoenix replied:\", payload))\n   *   .receive(\"error\", err => console.log(\"phoenix errored\", err))\n   *   .receive(\"timeout\", () => console.log(\"timed out pushing\"))\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n  push(event, payload, timeout = this.timeout){\n    payload = payload || {}\n    if(!this.joinedOnce){\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`)\n    }\n    let pushEvent = new Push(this, event, function (){ return payload }, timeout)\n    if(this.canPush()){\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  leave(timeout = this.timeout){\n    this.rejoinTimer.reset()\n    this.joinPush.cancelTimeout()\n\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, \"leave\")\n    }\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout)\n    leavePush.receive(\"ok\", () => onClose())\n      .receive(\"timeout\", () => onClose())\n    leavePush.send()\n    if(!this.canPush()){ leavePush.trigger(\"ok\", {}) }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n  onMessage(_event, payload, _ref){ return payload }\n\n  /**\n   * @private\n   */\n  isLifecycleEvent(event){ return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0 }\n\n  /**\n   * @private\n   */\n  isMember(topic, event, payload, joinRef){\n    if(this.topic !== topic){ return false }\n\n    if(joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)){\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {topic, event, payload, joinRef})\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @private\n   */\n  joinRef(){ return this.joinPush.ref }\n\n  /**\n   * @private\n   */\n  rejoin(timeout = this.timeout){\n    if(this.isLeaving()){ return }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /**\n   * @private\n   */\n  trigger(event, payload, ref, joinRef){\n    let handledPayload = this.onMessage(event, payload, ref, joinRef)\n    if(payload && !handledPayload){ throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\") }\n\n    let eventBindings = this.bindings.filter(bind => bind.event === event)\n\n    for(let i = 0; i < eventBindings.length; i++){\n      let bind = eventBindings[i]\n      bind.callback(handledPayload, ref, joinRef || this.joinRef())\n    }\n  }\n\n  /**\n   * @private\n   */\n  replyEventName(ref){ return `chan_reply_${ref}` }\n\n  /**\n   * @private\n   */\n  isClosed(){ return this.state === CHANNEL_STATES.closed }\n\n  /**\n   * @private\n   */\n  isErrored(){ return this.state === CHANNEL_STATES.errored }\n\n  /**\n   * @private\n   */\n  isJoined(){ return this.state === CHANNEL_STATES.joined }\n\n  /**\n   * @private\n   */\n  isJoining(){ return this.state === CHANNEL_STATES.joining }\n\n  /**\n   * @private\n   */\n  isLeaving(){ return this.state === CHANNEL_STATES.leaving }\n}\n","import {\n  global\n} from \"./constants\"\n\nexport default class Ajax {\n  constructor(){\n    this.states = {complete: 4}\n  }\n\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback){\n    if(global.XDomainRequest){\n      let req = new global.XDomainRequest() // IE8, IE9\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback)\n    } else {\n      let req = new global.XMLHttpRequest() // IE7+, Firefox, Chrome, Opera, Safari\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback)\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback){\n    req.timeout = timeout\n    req.open(method, endPoint)\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText)\n      callback && callback(response)\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => { }\n\n    req.send(body)\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback){\n    req.open(method, endPoint, true)\n    req.timeout = timeout\n    req.setRequestHeader(\"Content-Type\", accept)\n    req.onerror = () => { callback && callback(null) }\n    req.onreadystatechange = () => {\n      if(req.readyState === this.states.complete && callback){\n        let response = this.parseJSON(req.responseText)\n        callback(response)\n      }\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    req.send(body)\n  }\n\n  static parseJSON(resp){\n    if(!resp || resp === \"\"){ return null }\n\n    try {\n      return JSON.parse(resp)\n    } catch (e){\n      console && console.log(\"failed to parse JSON response\", resp)\n      return null\n    }\n  }\n\n  static serialize(obj, parentKey){\n    let queryStr = []\n    for(var key in obj){\n      if(!Object.prototype.hasOwnProperty.call(obj, key)){ continue }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key\n      let paramVal = obj[key]\n      if(typeof paramVal === \"object\"){\n        queryStr.push(this.serialize(paramVal, paramKey))\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal))\n      }\n    }\n    return queryStr.join(\"&\")\n  }\n\n  static appendParams(url, params){\n    if(Object.keys(params).length === 0){ return url }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\"\n    return `${url}${prefix}${this.serialize(params)}`\n  }\n}\n","import {\n  SOCKET_STATES,\n  TRANSPORTS\n} from \"./constants\"\n\nimport Ajax from \"./ajax\"\n\nexport default class LongPoll {\n\n  constructor(endPoint){\n    this.endPoint = null\n    this.token = null\n    this.skipHeartbeat = true\n    this.onopen = function (){ } // noop\n    this.onerror = function (){ } // noop\n    this.onmessage = function (){ } // noop\n    this.onclose = function (){ } // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint)\n    this.readyState = SOCKET_STATES.connecting\n\n    this.poll()\n  }\n\n  normalizeEndpoint(endPoint){\n    return (endPoint\n      .replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")\n      .replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll))\n  }\n\n  endpointURL(){\n    return Ajax.appendParams(this.pollEndpoint, {token: this.token})\n  }\n\n  closeAndRetry(){\n    this.close()\n    this.readyState = SOCKET_STATES.connecting\n  }\n\n  ontimeout(){\n    this.onerror(\"timeout\")\n    this.closeAndRetry()\n  }\n\n  poll(){\n    if(!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)){ return }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if(resp){\n        var {status, token, messages} = resp\n        this.token = token\n      } else {\n        status = 0\n      }\n\n      switch(status){\n        case 200:\n          messages.forEach(msg => {\n            // Tasks are what things like event handlers, setTimeout callbacks,\n            // promise resolves and more are run within.\n            // In modern browsers, there are two different kinds of tasks,\n            // microtasks and macrotasks.\n            // Microtasks are mainly used for Promises, while macrotasks are\n            // used for everything else.\n            // Microtasks always have priority over macrotasks. If the JS engine\n            // is looking for a task to run, it will always try to empty the\n            // microtask queue before attempting to run anything from the\n            // macrotask queue.\n            //\n            // For the WebSocket transport, messages always arrive in their own\n            // event. This means that if any promises are resolved from within,\n            // their callbacks will always finish execution by the time the\n            // next message event handler is run.\n            //\n            // In order to emulate this behaviour, we need to make sure each\n            // onmessage handler is run within it's own macrotask.\n            setTimeout(() => {\n              this.onmessage({data: msg})\n            }, 0)\n          })\n          this.poll()\n          break\n        case 204:\n          this.poll()\n          break\n        case 410:\n          this.readyState = SOCKET_STATES.open\n          this.onopen()\n          this.poll()\n          break\n        case 403:\n          this.onerror()\n          this.close()\n          break\n        case 0:\n        case 500:\n          this.onerror()\n          this.closeAndRetry()\n          break\n        default: throw new Error(`unhandled poll status ${status}`)\n      }\n    })\n  }\n\n  send(body){\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if(!resp || resp.status !== 200){\n        this.onerror(resp && resp.status)\n        this.closeAndRetry()\n      }\n    })\n  }\n\n  close(_code, _reason){\n    this.readyState = SOCKET_STATES.closed\n    this.onclose()\n  }\n}\n","/**\n * Initializes the Presence\n * @param {Channel} channel - The Channel\n * @param {Object} opts - The options,\n *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\nexport default class Presence {\n\n  constructor(channel, opts = {}){\n    let events = opts.events || {state: \"presence_state\", diff: \"presence_diff\"}\n    this.state = {}\n    this.pendingDiffs = []\n    this.channel = channel\n    this.joinRef = null\n    this.caller = {\n      onJoin: function (){ },\n      onLeave: function (){ },\n      onSync: function (){ }\n    }\n\n    this.channel.on(events.state, newState => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      this.joinRef = this.channel.joinRef()\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave)\n\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n      })\n      this.pendingDiffs = []\n      onSync()\n    })\n\n    this.channel.on(events.diff, diff => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      if(this.inPendingSyncState()){\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n        onSync()\n      }\n    })\n  }\n\n  onJoin(callback){ this.caller.onJoin = callback }\n\n  onLeave(callback){ this.caller.onLeave = callback }\n\n  onSync(callback){ this.caller.onSync = callback }\n\n  list(by){ return Presence.list(this.state, by) }\n\n  inPendingSyncState(){\n    return !this.joinRef || (this.joinRef !== this.channel.joinRef())\n  }\n\n  // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n  static syncState(currentState, newState, onJoin, onLeave){\n    let state = this.clone(currentState)\n    let joins = {}\n    let leaves = {}\n\n    this.map(state, (key, presence) => {\n      if(!newState[key]){\n        leaves[key] = presence\n      }\n    })\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key]\n      if(currentPresence){\n        let newRefs = newPresence.metas.map(m => m.phx_ref)\n        let curRefs = currentPresence.metas.map(m => m.phx_ref)\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0)\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0)\n        if(joinedMetas.length > 0){\n          joins[key] = newPresence\n          joins[key].metas = joinedMetas\n        }\n        if(leftMetas.length > 0){\n          leaves[key] = this.clone(currentPresence)\n          leaves[key].metas = leftMetas\n        }\n      } else {\n        joins[key] = newPresence\n      }\n    })\n    return this.syncDiff(state, {joins: joins, leaves: leaves}, onJoin, onLeave)\n  }\n\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n  static syncDiff(currentState, {joins, leaves}, onJoin, onLeave){\n    let state = this.clone(currentState)\n    if(!onJoin){ onJoin = function (){ } }\n    if(!onLeave){ onLeave = function (){ } }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key]\n      state[key] = newPresence\n      if(currentPresence){\n        let joinedRefs = state[key].metas.map(m => m.phx_ref)\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0)\n        state[key].metas.unshift(...curMetas)\n      }\n      onJoin(key, currentPresence, newPresence)\n    })\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key]\n      if(!currentPresence){ return }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref)\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0\n      })\n      onLeave(key, currentPresence, leftPresence)\n      if(currentPresence.metas.length === 0){\n        delete state[key]\n      }\n    })\n    return state\n  }\n\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n  static list(presences, chooser){\n    if(!chooser){ chooser = function (key, pres){ return pres } }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence)\n    })\n  }\n\n  // private\n\n  static map(obj, func){\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]))\n  }\n\n  static clone(obj){ return JSON.parse(JSON.stringify(obj)) }\n}\n","/* The default serializer for encoding and decoding messages */\nimport {\n  CHANNEL_EVENTS\n} from \"./constants\"\n\nexport default {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: {push: 0, reply: 1, broadcast: 2},\n\n  encode(msg, callback){\n    if(msg.payload.constructor === ArrayBuffer){\n      return callback(this.binaryEncode(msg))\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload]\n      return callback(JSON.stringify(payload))\n    }\n  },\n\n  decode(rawPayload, callback){\n    if(rawPayload.constructor === ArrayBuffer){\n      return callback(this.binaryDecode(rawPayload))\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload)\n      return callback({join_ref, ref, topic, event, payload})\n    }\n  },\n\n  // private\n\n  binaryEncode(message){\n    let {join_ref, ref, event, topic, payload} = message\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength)\n    let view = new DataView(header)\n    let offset = 0\n\n    view.setUint8(offset++, this.KINDS.push) // kind\n    view.setUint8(offset++, join_ref.length)\n    view.setUint8(offset++, ref.length)\n    view.setUint8(offset++, topic.length)\n    view.setUint8(offset++, event.length)\n    Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)))\n\n    var combined = new Uint8Array(header.byteLength + payload.byteLength)\n    combined.set(new Uint8Array(header), 0)\n    combined.set(new Uint8Array(payload), header.byteLength)\n\n    return combined.buffer\n  },\n\n  binaryDecode(buffer){\n    let view = new DataView(buffer)\n    let kind = view.getUint8(0)\n    let decoder = new TextDecoder()\n    switch(kind){\n      case this.KINDS.push: return this.decodePush(buffer, view, decoder)\n      case this.KINDS.reply: return this.decodeReply(buffer, view, decoder)\n      case this.KINDS.broadcast: return this.decodeBroadcast(buffer, view, decoder)\n    }\n  },\n\n  decodePush(buffer, view, decoder){\n    let joinRefSize = view.getUint8(1)\n    let topicSize = view.getUint8(2)\n    let eventSize = view.getUint8(3)\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1 // pushes have no ref\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize))\n    offset = offset + joinRefSize\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n    return {join_ref: joinRef, ref: null, topic: topic, event: event, payload: data}\n  },\n\n  decodeReply(buffer, view, decoder){\n    let joinRefSize = view.getUint8(1)\n    let refSize = view.getUint8(2)\n    let topicSize = view.getUint8(3)\n    let eventSize = view.getUint8(4)\n    let offset = this.HEADER_LENGTH + this.META_LENGTH\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize))\n    offset = offset + joinRefSize\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize))\n    offset = offset + refSize\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n    let payload = {status: event, response: data}\n    return {join_ref: joinRef, ref: ref, topic: topic, event: CHANNEL_EVENTS.reply, payload: payload}\n  },\n\n  decodeBroadcast(buffer, view, decoder){\n    let topicSize = view.getUint8(1)\n    let eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n\n    return {join_ref: null, ref: null, topic: topic, event: event, payload: data}\n  }\n}\n","/** Initializes the Socket *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {Function} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON encoder.\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n * @param {vsn} [opts.vsn] - The serializer's protocol version to send on connect.\n *\n * Defaults to DEFAULT_VSN.\n*/\n\nimport {\n  global,\n  phxWindow,\n  CHANNEL_EVENTS,\n  DEFAULT_TIMEOUT,\n  DEFAULT_VSN,\n  SOCKET_STATES,\n  TRANSPORTS,\n  WS_CLOSE_NORMAL\n} from \"./constants\"\n\nimport {\n  closure\n} from \"./utils\"\n\nimport Ajax from \"./ajax\"\nimport Channel from \"./channel\"\nimport LongPoll from \"./longpoll\"\nimport Serializer from \"./serializer\"\nimport Timer from \"./timer\"\n\nexport default class Socket {\n  constructor(endPoint, opts = {}){\n    this.stateChangeCallbacks = {open: [], close: [], error: [], message: []}\n    this.channels = []\n    this.sendBuffer = []\n    this.ref = 0\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT\n    this.transport = opts.transport || global.WebSocket || LongPoll\n    this.defaultEncoder = Serializer.encode.bind(Serializer)\n    this.defaultDecoder = Serializer.decode.bind(Serializer)\n    this.closeWasClean = false\n    this.binaryType = opts.binaryType || \"arraybuffer\"\n    this.connectClock = 1\n    if(this.transport !== LongPoll){\n      this.encode = opts.encode || this.defaultEncoder\n      this.decode = opts.decode || this.defaultDecoder\n    } else {\n      this.encode = this.defaultEncoder\n      this.decode = this.defaultDecoder\n    }\n    let awaitingConnectionOnPageShow = null\n    if(phxWindow && phxWindow.addEventListener){\n      phxWindow.addEventListener(\"pagehide\", _e => {\n        if(this.conn){\n          this.disconnect()\n          awaitingConnectionOnPageShow = this.connectClock\n        }\n      })\n      phxWindow.addEventListener(\"pageshow\", _e => {\n        if(awaitingConnectionOnPageShow === this.connectClock){\n          awaitingConnectionOnPageShow = null\n          this.connect()\n        }\n      })\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000\n    this.rejoinAfterMs = (tries) => {\n      if(opts.rejoinAfterMs){\n        return opts.rejoinAfterMs(tries)\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000\n      }\n    }\n    this.reconnectAfterMs = (tries) => {\n      if(opts.reconnectAfterMs){\n        return opts.reconnectAfterMs(tries)\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n      }\n    }\n    this.logger = opts.logger || null\n    this.longpollerTimeout = opts.longpollerTimeout || 20000\n    this.params = closure(opts.params || {})\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.vsn = opts.vsn || DEFAULT_VSN\n    this.heartbeatTimer = null\n    this.pendingHeartbeatRef = null\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect())\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n  protocol(){ return location.protocol.match(/^https/) ? \"wss\" : \"ws\" }\n\n  /**\n   * The fully qualifed socket url\n   *\n   * @returns {string}\n   */\n  endPointURL(){\n    let uri = Ajax.appendParams(\n      Ajax.appendParams(this.endPoint, this.params()), {vsn: this.vsn})\n    if(uri.charAt(0) !== \"/\"){ return uri }\n    if(uri.charAt(1) === \"/\"){ return `${this.protocol()}:${uri}` }\n\n    return `${this.protocol()}://${location.host}${uri}`\n  }\n\n  /**\n   * Disconnects the socket\n   *\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.\n   *\n   * @param {Function} callback - Optional callback which is called after socket is disconnected.\n   * @param {integer} code - A status code for disconnection (Optional).\n   * @param {string} reason - A textual description of the reason to disconnect. (Optional)\n   */\n  disconnect(callback, code, reason){\n    this.connectClock++\n    this.closeWasClean = true\n    this.reconnectTimer.reset()\n    this.teardown(callback, code, reason)\n  }\n\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n  connect(params){\n    this.connectClock++\n    if(params){\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\")\n      this.params = closure(params)\n    }\n    if(this.conn){ return }\n    this.closeWasClean = false\n    this.conn = new this.transport(this.endPointURL())\n    this.conn.binaryType = this.binaryType\n    this.conn.timeout = this.longpollerTimeout\n    this.conn.onopen = () => this.onConnOpen()\n    this.conn.onerror = error => this.onConnError(error)\n    this.conn.onmessage = event => this.onConnMessage(event)\n    this.conn.onclose = event => this.onConnClose(event)\n  }\n\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n  log(kind, msg, data){ this.logger(kind, msg, data) }\n\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n  hasLogger(){ return this.logger !== null }\n\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n  onOpen(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.open.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n  onClose(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.close.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n  onError(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.error.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n  onMessage(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.message.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * @private\n   */\n  onConnOpen(){\n    if(this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`)\n    this.closeWasClean = false\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.resetHeartbeat()\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback())\n  }\n\n  /**\n   * @private\n   */\n\n  heartbeatTimeout(){\n    if(this.pendingHeartbeatRef){\n      this.pendingHeartbeatRef = null\n      if(this.hasLogger()){ this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\") }\n      this.abnormalClose(\"heartbeat timeout\")\n    }\n  }\n\n  resetHeartbeat(){\n    if(this.conn && this.conn.skipHeartbeat){ return }\n    this.pendingHeartbeatRef = null\n    clearTimeout(this.heartbeatTimer)\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n  }\n\n  teardown(callback, code, reason){\n    if(!this.conn){\n      return callback && callback()\n    }\n\n    this.waitForBufferDone(() => {\n      if(this.conn){\n        if(code){ this.conn.close(code, reason || \"\") } else { this.conn.close() }\n      }\n\n      this.waitForSocketClosed(() => {\n        if(this.conn){\n          this.conn.onclose = function (){ } // noop\n          this.conn = null\n        }\n\n        callback && callback()\n      })\n    })\n  }\n\n  waitForBufferDone(callback, tries = 1){\n    if(tries === 5 || !this.conn || !this.conn.bufferedAmount){\n      callback()\n      return\n    }\n\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1)\n    }, 150 * tries)\n  }\n\n  waitForSocketClosed(callback, tries = 1){\n    if(tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed){\n      callback()\n      return\n    }\n\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1)\n    }, 150 * tries)\n  }\n\n  onConnClose(event){\n    if(this.hasLogger()) this.log(\"transport\", \"close\", event)\n    this.triggerChanError()\n    clearTimeout(this.heartbeatTimer)\n    if(!this.closeWasClean){\n      this.reconnectTimer.scheduleTimeout()\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event))\n  }\n\n  /**\n   * @private\n   */\n  onConnError(error){\n    if(this.hasLogger()) this.log(\"transport\", error)\n    this.triggerChanError()\n    this.stateChangeCallbacks.error.forEach(([, callback]) => callback(error))\n  }\n\n  /**\n   * @private\n   */\n  triggerChanError(){\n    this.channels.forEach(channel => {\n      if(!(channel.isErrored() || channel.isLeaving() || channel.isClosed())){\n        channel.trigger(CHANNEL_EVENTS.error)\n      }\n    })\n  }\n\n  /**\n   * @returns {string}\n   */\n  connectionState(){\n    switch(this.conn && this.conn.readyState){\n      case SOCKET_STATES.connecting: return \"connecting\"\n      case SOCKET_STATES.open: return \"open\"\n      case SOCKET_STATES.closing: return \"closing\"\n      default: return \"closed\"\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isConnected(){ return this.connectionState() === \"open\" }\n\n  /**\n   * @private\n   *\n   * @param {Channel}\n   */\n  remove(channel){\n    this.off(channel.stateChangeRefs)\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef())\n  }\n\n  /**\n   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.\n   *\n   * @param {refs} - list of refs returned by calls to\n   *                 `onOpen`, `onClose`, `onError,` and `onMessage`\n   */\n  off(refs){\n    for(let key in this.stateChangeCallbacks){\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1\n      })\n    }\n  }\n\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n  channel(topic, chanParams = {}){\n    let chan = new Channel(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * @param {Object} data\n   */\n  push(data){\n    if(this.hasLogger()){\n      let {topic, event, payload, ref, join_ref} = data\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload)\n    }\n\n    if(this.isConnected()){\n      this.encode(data, result => this.conn.send(result))\n    } else {\n      this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)))\n    }\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n  makeRef(){\n    let newRef = this.ref + 1\n    if(newRef === this.ref){ this.ref = 0 } else { this.ref = newRef }\n\n    return this.ref.toString()\n  }\n\n  sendHeartbeat(){\n    if(this.pendingHeartbeatRef && !this.isConnected()){ return }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef})\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs)\n  }\n\n  abnormalClose(reason){\n    this.closeWasClean = false\n    if(this.isConnected()){ this.conn.close(WS_CLOSE_NORMAL, reason) }\n  }\n\n  flushSendBuffer(){\n    if(this.isConnected() && this.sendBuffer.length > 0){\n      this.sendBuffer.forEach(callback => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  onConnMessage(rawMessage){\n    this.decode(rawMessage.data, msg => {\n      let {topic, event, payload, ref, join_ref} = msg\n      if(ref && ref === this.pendingHeartbeatRef){\n        clearTimeout(this.heartbeatTimer)\n        this.pendingHeartbeatRef = null\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n      }\n\n      if(this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload)\n\n      for(let i = 0; i < this.channels.length; i++){\n        const channel = this.channels[i]\n        if(!channel.isMember(topic, event, payload, join_ref)){ continue }\n        channel.trigger(event, payload, ref, join_ref)\n      }\n\n      for(let i = 0; i < this.stateChangeCallbacks.message.length; i++){\n        let [, callback] = this.stateChangeCallbacks.message[i]\n        callback(msg)\n      }\n    })\n  }\n\n  leaveOpenTopic(topic){\n    let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()))\n    if(dupChannel){\n      if(this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`)\n      dupChannel.leave()\n    }\n  }\n}\n","var ___EXPOSE_LOADER_IMPORT___ = require(\"-!./index.js\");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = require(\"../../node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"Phoenix\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"Phoenix\"] = ___EXPOSE_LOADER_IMPORT___;\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n","\"use strict\";\n\n// eslint-disable-next-line func-names\nmodule.exports = function () {\n  if (typeof globalThis === \"object\") {\n    return globalThis;\n  }\n\n  var g;\n\n  try {\n    // This works if eval is allowed (see CSP)\n    // eslint-disable-next-line no-new-func\n    g = this || new Function(\"return this\")();\n  } catch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\") {\n      return window;\n    } // This works if the self reference is available\n\n\n    if (typeof self === \"object\") {\n      return self;\n    } // This works if the global reference is available\n\n\n    if (typeof global !== \"undefined\") {\n      return global;\n    }\n  }\n\n  return g;\n}();","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(864);\n"],"sourceRoot":""}